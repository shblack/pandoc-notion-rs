
“Batteries included” functions¶

These are functions commonly used when writing more complex filters

  ------------------------------------------------- ---------------------------------------------------------------------------
  stringify(element[, newlines])                    Return the raw text version of an element (and its children elements).
  convert_text(text[, input_format, ...])           Convert formatted text (usually markdown) by calling Pandoc internally
  yaml_filter(element, doc[, tag, function, ...])   Convenience function for parsing code blocks with YAML options
  debug(*args, **kwargs)                            Same as print, but prints to stderr (which is not intercepted by Pandoc).
  shell(args[, wait, msg])                          Execute the external command and get its exitcode, stdout and stderr.
  ------------------------------------------------- ---------------------------------------------------------------------------

See also Doc.get_metadata and Element.replace_keyword

Useful (but not essential) functions for writing panflute filters

class PandocVersion[source]¶

    Get runtime Pandoc version

    use PandocVersion().version for comparing versions

convert_text(text, input_format='markdown', output_format='panflute', standalone=False, extra_args=None, pandoc_path=None)[source]¶

    Convert formatted text (usually markdown) by calling Pandoc
    internally

    The default output format (‘panflute’) will return a tree of Pandoc
    elements. When combined with ‘standalone=True’, the tree root will
    be a ‘Doc’ element.

    Example:

        >>> from panflute import *
        >>> md = 'Some *markdown* **text** ~xyz~'
        >>> tex = r'Some $x^y$ or $x_n = \sqrt{a + b}$ \textit{a}'
        >>> convert_text(md)
        [Para(Str(Some) Space Emph(Str(markdown)) Space Strong(Str(text)) Space Subscript(Str(xyz)))]
        >>> convert_text(tex)
        [Para(Str(Some) Space Math(x^y; format='InlineMath') Space Str(or) Space Math(x_n = \sqrt{a + b}; format='InlineMath') Space RawInline(\textit{a}; format='tex'))]

    Parameters:

        - text (str | Element | list of Element) – text that will be
          converted

        - input_format – format of the text (default ‘markdown’). Any
          Pandoc input format is valid, plus ‘panflute’ (a tree of
          Pandoc elements)

        - output_format – format of the output (default is ‘panflute’
          which creates the tree of Pandoc elements). Non-binary Pandoc
          formats are allowed (e.g. markdown, latex is allowed, but docx
          and pdf are not).

        - standalone (bool) – whether the results will be a standalone
          document or not.

        - extra_args (list) – extra arguments passed to Pandoc

        - pandoc_path (str) – If specified, use the Pandoc at this path.
          If None, default to that from PATH.

    Return type:

        list | Doc | str

    Note: for a more general solution, see pyandoc by Kenneth Reitz.

get_option(options=None, local_tag=None, doc=None, doc_tag=None, default=None, error_on_none=True)[source]¶

    Fetch an option variable from either a local (element) level
    option/attribute tag, a document level metadata tag, or a default.



      type options:

          dict

      type local_tag:

          str

      type doc:

          Doc

      type doc_tag:

          str

      type default:

          any

      type error_on_none:

          bool

    The order of preference is local > document > default, although if a
    local or document tag returns None, then the next level down is
    used. Also, if error_on_none=True and the final variable is None,
    then a ValueError will be raised

    In this manner you can set global variables, which can be optionally
    overridden at a local level. For example, the two files below show
    how to apply different styles to docx text:

    main.md:

         1------------------
         2style-div:
         3    name: MyStyle
         4------------------
         5
         6:::style
         7some text
         8:::
         9
        10::: {.style name=MyOtherStyle}
        11some more text
        12:::

    style_filter.py:

         1import panflute as pf
         2
         3def action(elem, doc):
         4    if type(elem) == pf.Div:
         5        style = pf.get_option(elem.attributes, "name", doc, "style-div.name")
         6        elem.attributes["custom-style"] = style
         7
         8def main(doc=None):
         9    return run_filter(action, doc=doc)
        10
        11if __name__ == "__main__":
        12    main()

run_pandoc(text='', args=None, pandoc_path=None)[source]¶

    Low level function that calls Pandoc with (optionally) some input
    text and/or arguments

    Parameters:

        pandoc_path (str) – If specified, use the Pandoc at this path.
        If None, default to that from PATH.

shell(args, wait=True, msg=None)[source]¶

    Execute the external command and get its exitcode, stdout and
    stderr.

stringify(element, newlines=True)[source]¶

      Return the raw text version of an element (and its children
      elements).

      Example:

          >>> from panflute import *
          >>> e1 = Emph(Str('Hello'), Space, Str('world!'))
          >>> e2 = Strong(Str('Bye!'))
          >>> para = Para(e1, Space, e2)
          >>> stringify(para)
          'Hello world! Bye!

    ‘



      param newlines:

          add a new line after a paragraph (default True)

      type newlines:

          bool

      rtype:

          str

yaml_filter(element, doc, tag=None, function=None, tags=None, strict_yaml=False)[source]¶

    Convenience function for parsing code blocks with YAML options

    This function is useful to create a filter that applies to code
    blocks that have specific classes.

    It is used as an argument of run_filter, with two additional
    options: tag and function.

    Using this is equivalent to having filter functions that:

    1.  Check if the element is a code block

    2.  Check if the element belongs to a specific class

    3.  Split the YAML options (at the beginning of the block, by
        looking for ... or --- strings in a separate line

    4.  Parse the YAML

    5.  Use the YAML options and (optionally) the data that follows the
        YAML to return a new or modified element

    Instead, you just need to:

    1.  Call run_filter with yaml_filter as the action function, and
        with the additional arguments tag and function

    2.  Construct a fenced_action function that takes four arguments:
        (options, data, element, doc). Note that options is a dict and
        data is a raw string. Notice that this is similar to the action
        functions of standard filters, but with options and data as the
        new ones.

    Note: if you want to apply multiple functions to separate classes,
    you can use the tags argument, which receives a dict of
    tag: function pairs.

    Note: use the strict_yaml=True option in order to allow for more
    verbose but flexible YAML metadata: more than one YAML blocks are
    allowed, but they all must start with --- (even at the beginning)
    and end with --- or .... Also, YAML is not the default content when
    no delimiters are set.

    Example:

        """
        Replace code blocks of class 'foo' with # horizontal rules
        """

        import panflute as pf

        def fenced_action(options, data, element, doc):
            count = options.get('count', 1)
            div = pf.Div(attributes={'count': str(count)})
            div.content.extend([pf.HorizontalRule] * count)
            return div

        if __name__ == '__main__':
            pf.run_filter(pf.yaml_filter, tag='foo', function=fenced_action)
