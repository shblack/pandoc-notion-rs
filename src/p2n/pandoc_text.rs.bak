//! Converter for Pandoc inline elements to Notion rich text
//!
//! This module provides the functionality to convert Pandoc's inline elements
//! (such as text, formatting, equations, and links) into Notion's rich text objects.
//! The conversion preserves formatting attributes and handles nested structures.

use notion_client::objects::rich_text::{Annotations, Equation, Link, RichText, Text, TextColor};
use pandoc_types::definition::{Inline, Target};
use std::error::Error;
use std::fmt;
use std::rc::Rc;
use std::cell::RefCell;

/// Errors that can occur during the conversion process
#[derive(Debug, Clone)]
pub enum ConversionError {
    /// Element type is not supported
    UnsupportedElement(String),
    /// Invalid formatting or structure
    InvalidFormat(String),
}

impl fmt::Display for ConversionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConversionError::UnsupportedElement(msg) => write!(f, "Unsupported element: {}", msg),
            ConversionError::InvalidFormat(msg) => write!(f, "Invalid format: {}", msg),
        }
    }
}

impl Error for ConversionError {}

/// Configuration options for the conversion process
///
/// These settings control how whitespace and line breaks are handled
/// during the conversion from Pandoc elements to Notion rich text.
#[derive(Debug, Clone)]
pub struct ConversionConfig {
    /// If true, LineBreak elements will be preserved as newlines
    pub preserve_line_breaks: bool,
    /// If true, spaces and tabs will be preserved exactly as they appear
    pub preserve_whitespace: bool,
    /// If true, consecutive whitespace will be collapsed to a single space
    pub collapse_whitespace: bool,
}

impl Default for ConversionConfig {
    fn default() -> Self {
        ConversionConfig {
            preserve_line_breaks: true,
            preserve_whitespace: true,
            collapse_whitespace: false,
        }
    }
}

/// Builder for constructing Notion rich text objects
///
/// This manages a buffer of text with its formatting attributes
/// and creates rich text objects when needed.
#[derive(Clone)]
pub struct TextBuilder {
    current_text: String,
    annotations: Annotations,
    link: Option<Link>,
    rich_texts: Vec<RichText>,
}

impl TextBuilder {
    /// Get the current annotation settings
    pub fn get_annotations(&self) -> Annotations {
        self.annotations.clone()
    }

    /// Set the current annotation settings
    pub fn set_annotations(&mut self, annotations: Annotations) {
        self.annotations = annotations;
    }

    /// Update a specific annotation property
    pub fn update_annotation<F>(&mut self, updater: F)
    where
        F: FnOnce(&mut Annotations),
    {
        updater(&mut self.annotations);
    }
}

impl TextBuilder {
    /// Create a new TextBuilder with default settings
    pub fn new() -> Self {
        TextBuilder {
            current_text: String::new(),
            annotations: Annotations::default(),
            link: None,
            rich_texts: Vec::new(),
        }
    }

    /// Commit any current text in the buffer to rich text objects
    pub fn commit_current_text(&mut self) -> Result<(), ConversionError> {
        if !self.current_text.is_empty() {
            let text_content = Text {
                content: self.current_text.clone(),
                link: self.link.clone(),
            };

            let rich_text = RichText::Text {
                text: text_content,
                annotations: Some(self.annotations.clone()),
                plain_text: Some(self.current_text.clone()),
                href: self.link.as_ref().map(|link| link.url.clone()),
            };

            self.rich_texts.push(rich_text);
            self.current_text.clear();
        }
        Ok(())
    }

    /// Commit an equation to the rich text objects
    pub fn commit_equation(&mut self, expression: &str) -> Result<(), ConversionError> {
        // First commit any current text
        self.commit_current_text()?;

        let equation = Equation {
            expression: expression.to_string(),
        };

        let rich_text = RichText::Equation {
            equation,
            annotations: self.annotations.clone(),
            plain_text: expression.to_string(),
            href: None,
        };

        self.rich_texts.push(rich_text);
        Ok(())
    }

    /// Apply formatting to a section of content
    pub fn apply_formatting<F>(&mut self, formatter: F) -> TextBuilder
    where
        F: FnOnce(&mut Annotations),
    {
        // First commit any accumulated text with current formatting
        if let Err(e) = self.commit_current_text() {
            // In practice, commit_current_text never fails in our implementation
            panic!("Failed to commit text: {}", e);
        }

        // Create a new builder with the same settings
        let mut new_builder = TextBuilder::new();
        
        // Copy the current annotations
        new_builder.annotations = self.annotations.clone();
        
        // Apply the formatting changes
        formatter(&mut new_builder.annotations);
        
        new_builder
    }

    /// Append text to the current buffer
    pub fn append_text(&mut self, text: &str) {
        self.current_text.push_str(text);
    }

    /// This commits any remaining text in the buffer and returns the
    /// complete list of rich text objects that have been built.
    pub fn build(mut self) -> Result<Vec<RichText>, ConversionError> {
        self.commit_current_text()?;
        Ok(self.rich_texts)
    }

    /// Set the link for the current text segment
    pub fn set_link(&mut self, link: Option<Link>) {
        self.link = link;
    }
}

/// Handler for converting a specific Pandoc element type to Notion rich text
pub trait PandocElementHandler {
    /// Check if this handler can process the given element
    fn can_handle(&self, element: &Inline) -> bool;

    /// Process the element and update the builder accordingly
    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError>;
}

/// Main converter for transforming Pandoc inline elements to Notion rich text
///
/// This orchestrates the conversion process using a set of element handlers.
pub struct PandocTextConverter {
    /// The set of handlers for different element types
    handlers: Vec<Box<dyn PandocElementHandler>>,
    /// Configuration options for the conversion
    config: ConversionConfig,
}

impl PandocTextConverter {
    /// Create a new converter with default configuration
    pub fn new() -> Self {
        println!("PandocTextConverter: Creating new converter");
        Self::with_config(ConversionConfig::default())
    }

    /// Create a new converter with the specified configuration
    pub fn with_config(config: ConversionConfig) -> Self {
        let converter_ref = Rc::new(RefCell::new(None::<PandocTextConverter>));
        let handlers = Self::create_default_handlers(converter_ref.clone(), &config);
        
        let converter = PandocTextConverter { handlers, config };
        *converter_ref.borrow_mut() = Some(converter.clone());
        
        converter
    }

    /// Create the standard set of element handlers
    fn create_default_handlers(
        converter_ref: Rc<RefCell<Option<PandocTextConverter>>>,
        config: &ConversionConfig,
    ) -> Vec<Box<dyn PandocElementHandler>> {
        vec![
            Box::new(StrHandler {}),
            Box::new(SpaceHandler {}),
            Box::new(BreakHandler::new(config.clone())),
            Box::new(StrongHandler::new(converter_ref.clone())),
            Box::new(EmphHandler::new(converter_ref.clone())),
            Box::new(StrikeoutHandler::new(converter_ref.clone())),
            Box::new(CodeHandler::new(converter_ref.clone())),
            Box::new(MathHandler {}),
            Box::new(LinkHandler::new(converter_ref.clone())),
            Box::new(SpanHandler::new(converter_ref)),
        ]
    }

    /// Convert a list of Pandoc inline elements to Notion rich text objects
    ///
    /// This is the main entry point for the conversion process.
    pub fn convert(&self, elements: &[Inline]) -> Result<Vec<RichText>, ConversionError> {
        println!("PandocTextConverter: Converting with {} handlers", self.handlers.len());
        
        let mut builder = TextBuilder::new();
        self.convert_content(elements, &mut builder)?;
        builder.build()
    }

    /// Internal method to convert content with a given builder
    /// 
    /// This is used recursively by some handlers for nested elements.
    fn convert_content(&self, elements: &[Inline], builder: &mut TextBuilder) -> Result<(), ConversionError> {
        println!("PandocTextConverter: Converting elements: {:?}", elements);
        for element in elements {
            let mut handled = false;
            
            for handler in &self.handlers {
                if handler.can_handle(element) {
                    println!("PandocTextConverter: Handler found for element: {:?}", element);
                    handler.handle(element, builder)?;
                    handled = true;
                    break;
                }
            }
            
            if !handled {
                println!("PandocTextConverter: No handler found for element: {:?}", element);
                return Err(ConversionError::UnsupportedElement(format!("{:?}", element)));
            }
        }
        Ok(())
    }
}

impl Clone for PandocTextConverter {
    fn clone(&self) -> Self {
        // We need to do a deep clone - clone the config and handlers
        let config = self.config.clone();
        
        // First create a converter with empty handlers
        let mut new_converter = PandocTextConverter {
            handlers: Vec::new(),
            config,
        };
        
        // Create a new reference that will point to the new converter
        let new_ref = Rc::new(RefCell::new(Some(new_converter.clone())));
        
        // Create new handlers with the new reference
        new_converter.handlers = Self::create_default_handlers(new_ref, &new_converter.config);
        
        // Update the reference to point to the updated converter
        *new_ref.borrow_mut() = Some(new_converter.clone());
        
        new_converter
    }
}

/// Handler for plain text elements (Str)
pub struct StrHandler;

impl PandocElementHandler for StrHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Str(_))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Str(text) = element {
            builder.append_text(text);
            Ok(())
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for space elements (Space)
pub struct SpaceHandler;

impl PandocElementHandler for SpaceHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Space)
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Space = element {
            builder.append_text(" ");
            Ok(())
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for line break elements (SoftBreak, LineBreak)
pub struct BreakHandler {
    config: ConversionConfig,
}

impl BreakHandler {
    pub fn new(config: ConversionConfig) -> Self {
        BreakHandler { config }
    }
}

impl PandocElementHandler for BreakHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::SoftBreak | Inline::LineBreak)
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        match element {
            Inline::SoftBreak => {
                // SoftBreak is typically rendered as a space
                builder.append_text(" ");
            }
            Inline::LineBreak => {
                if self.config.preserve_line_breaks {
                    builder.append_text("\n");
                } else {
                    builder.append_text(" ");
                }
            }
            _ => return Err(ConversionError::UnsupportedElement(format!("{:?}", element))),
        }
        Ok(())
    }
}

/// Handler for bold text elements (Strong)
pub struct StrongHandler {
    converter: Rc<RefCell<Option<PandocTextConverter>>>,
}

impl StrongHandler {
    pub fn new(converter: Rc<RefCell<Option<PandocTextConverter>>>) -> Self {
        StrongHandler { converter }
    }
}

impl PandocElementHandler for StrongHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Strong(_))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Strong(content) = element {
            println!("StrongHandler: Processing Strong element with content: {:?}", content);
            let converter_ref = self.converter.borrow();
            if let Some(converter) = converter_ref.as_ref() {
                println!("StrongHandler: Converter has {} handlers", converter.handlers.len());
                // Set bold formatting for the nested content
                let mut nested_builder = builder.apply_formatting(|annotations| {
                    annotations.bold = true;
                });
                
                // If the converter has no handlers, we need to use a clone with proper handlers
                let converter_to_use = if converter.handlers.is_empty() {
                    println!("StrongHandler: Using fresh converter since handler count is 0");
                    PandocTextConverter::with_config(converter.config.clone())
                } else {
                    converter.clone()
                };
                
                // Process the nested content
                println!("StrongHandler: Converting nested content");
                converter_to_use.convert_content(content, &mut nested_builder)?;
                
                // Restore previous annotations when we're done with nested content
                println!("StrongHandler: Building result");
                if let Ok(rich_texts) = nested_builder.build() {
                    println!("StrongHandler: Rich texts built: {:?}", rich_texts);
                    for rich_text in rich_texts {
                        match rich_text {
                            RichText::Text { text, annotations, plain_text, href } => {
                                let new_text = RichText::Text {
                                    text,
                                    annotations: Some(annotations.unwrap_or_default()),
                                    plain_text,
                                    href,
                                };
                                builder.rich_texts.push(new_text);
                            }
                            // For other types like Equation or Mention, just add them directly
                            _ => builder.rich_texts.push(rich_text),
                        }
                    }
                } else {
                    println!("StrongHandler: Failed to build rich texts");
                }
                
                Ok(())
            } else {
                Err(ConversionError::InvalidFormat("Converter not initialized".to_string()))
            }
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for italic text elements (Emph)
pub struct EmphHandler {
    converter: Rc<RefCell<Option<PandocTextConverter>>>,
}

impl EmphHandler {
    pub fn new(converter: Rc<RefCell<Option<PandocTextConverter>>>) -> Self {
        EmphHandler { converter }
    }
}

impl PandocElementHandler for EmphHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Emph(_))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Emph(content) = element {
            let converter_ref = self.converter.borrow();
            if let Some(converter) = converter_ref.as_ref() {
                // Set italic formatting for the nested content
                let mut nested_builder = builder.apply_formatting(|annotations| {
                    annotations.italic = true;
                });
                
                // If the converter has no handlers, we need to use a clone with proper handlers
                let converter_to_use = if converter.handlers.is_empty() {
                    PandocTextConverter::with_config(converter.config.clone())
                } else {
                    converter.clone()
                };
                
                // Process the nested content
                converter_to_use.convert_content(content, &mut nested_builder)?;
                
                // Restore previous annotations when we're done with nested content
                if let Ok(rich_texts) = nested_builder.build() {
                    for rich_text in rich_texts {
                        match rich_text {
                            RichText::Text { text, annotations, plain_text, href } => {
                                let new_text = RichText::Text {
                                    text,
                                    annotations: Some(annotations.unwrap_or_default()),
                                    plain_text,
                                    href,
                                };
                                builder.rich_texts.push(new_text);
                            }
                            // For other types like Equation or Mention, just add them directly
                            _ => builder.rich_texts.push(rich_text),
                        }
                    }
                }
                
                Ok(())
            } else {
                Err(ConversionError::InvalidFormat("Converter not initialized".to_string()))
            }
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for strikethrough text elements (Strikeout)
pub struct StrikeoutHandler {
    converter: Rc<RefCell<Option<PandocTextConverter>>>,
}

impl StrikeoutHandler {
    pub fn new(converter: Rc<RefCell<Option<PandocTextConverter>>>) -> Self {
        StrikeoutHandler { converter }
    }
}

impl PandocElementHandler for StrikeoutHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Strikeout(_))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Strikeout(content) = element {
            let converter_ref = self.converter.borrow();
            if let Some(converter) = converter_ref.as_ref() {
                // Set strikethrough formatting for the nested content
                let mut nested_builder = builder.apply_formatting(|annotations| {
                    annotations.strikethrough = true;
                });
                
                // If the converter has no handlers, we need to use a clone with proper handlers
                let converter_to_use = if converter.handlers.is_empty() {
                    PandocTextConverter::with_config(converter.config.clone())
                } else {
                    converter.clone()
                };
                
                // Process the nested content
                converter_to_use.convert_content(content, &mut nested_builder)?;
                
                // Restore previous annotations when we're done with nested content
                if let Ok(rich_texts) = nested_builder.build() {
                    for rich_text in rich_texts {
                        match rich_text {
                            RichText::Text { text, annotations, plain_text, href } => {
                                let new_text = RichText::Text {
                                    text,
                                    annotations: Some(annotations.unwrap_or_default()),
                                    plain_text,
                                    href,
                                };
                                builder.rich_texts.push(new_text);
                            }
                            // For other types like Equation or Mention, just add them directly
                            _ => builder.rich_texts.push(rich_text),
                        }
                    }
                }
                
                Ok(())
            } else {
                Err(ConversionError::InvalidFormat("Converter not initialized".to_string()))
            }
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for inline code elements (Code)
pub struct CodeHandler {
    converter: Rc<RefCell<Option<PandocTextConverter>>>,
}

impl CodeHandler {
    pub fn new(converter: Rc<RefCell<Option<PandocTextConverter>>>) -> Self {
        CodeHandler { converter }
    }
}

impl PandocElementHandler for CodeHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Code(_, _))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Code(_, code_text) = element {
            // Commit any existing text first
            builder.commit_current_text()?;
            
            // Create a new builder with code formatting
            let mut nested_builder = builder.apply_formatting(|annotations| {
                annotations.code = true;
            });
            
            // Add the code text
            nested_builder.append_text(code_text);
            
            // Commit the code text
            nested_builder.commit_current_text()?;
            
            // Transfer the rich texts back to the original builder
            if let Ok(rich_texts) = nested_builder.build() {
                builder.rich_texts.extend(rich_texts);
            }
            
            Ok(())
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for math elements (Math)
pub struct MathHandler;

impl PandocElementHandler for MathHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Math(_, _))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Math(_, expression) = element {
            // Equation elements need special handling
            builder.commit_equation(expression)?;
            Ok(())
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for link elements (Link)
pub struct LinkHandler {
    converter: Rc<RefCell<Option<PandocTextConverter>>>,
}

impl LinkHandler {
    pub fn new(converter: Rc<RefCell<Option<PandocTextConverter>>>) -> Self {
        LinkHandler { converter }
    }
}

impl PandocElementHandler for LinkHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Link(_, _, _))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Link(_, content, Target { url, title: _ }) = element {
            let converter_ref = self.converter.borrow();
            if let Some(converter) = converter_ref.as_ref() {
                // Create a link object
                let link = Link { 
                    url: url.clone() 
                };
                
                // Set the link for the nested content
                builder.commit_current_text()?;
                
                let mut nested_builder = TextBuilder::new();
                nested_builder.set_annotations(builder.get_annotations());
                nested_builder.set_link(Some(link));
                
                // Process the link content
                converter.convert_content(content, &mut nested_builder)?;
                
                // Add the link text to the builder
                if let Ok(rich_texts) = nested_builder.build() {
                    builder.rich_texts.extend(rich_texts);
                }
                
                Ok(())
            } else {
                Err(ConversionError::InvalidFormat("Converter not initialized".to_string()))
            }
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

/// Handler for span elements (Span)
///
/// This handles spans with CSS class names, potentially
/// converting them to Notion's colors and underline formatting.
pub struct SpanHandler {
    converter: Rc<RefCell<Option<PandocTextConverter>>>,
}

impl SpanHandler {
    pub fn new(converter: Rc<RefCell<Option<PandocTextConverter>>>) -> Self {
        Self { converter }
    }
    
    /// Extract a Notion color from CSS class names
    ///
    /// This parses color classes in the format "color-red" or "color-blue-background"
    /// and converts them to the appropriate Notion color enum values.
    fn parse_color(&self, classes: &[String]) -> Option<TextColor> {
        for class in classes {
            if class == "underline" {
                // This is an underline span, not a color
                return None;
            }
            
            if class.starts_with("color-") {
                let color_part = &class["color-".len()..];
                
                // Handle background colors
                if color_part.ends_with("-background") {
                    let base_color = &color_part[0..color_part.len() - 11]; // Remove "-background"
                    return match base_color {
                        "red" => Some(TextColor::RedBackground),
                        "blue" => Some(TextColor::BlueBackground),
                        "green" => Some(TextColor::GreenBackground),
                        "yellow" => Some(TextColor::YellowBackground),
                        "orange" => Some(TextColor::OrangeBackground),
                        "pink" => Some(TextColor::PinkBackground),
                        "purple" => Some(TextColor::PurpleBackground),
                        "brown" => Some(TextColor::BrownBackground),
                        "gray" => Some(TextColor::GrayBackground),
                        _ => None,
                    };
                } else {
                    // Regular colors
                    return match color_part {
                        "red" => Some(TextColor::Red),
                        "blue" => Some(TextColor::Blue),
                        "green" => Some(TextColor::Green),
                        "yellow" => Some(TextColor::Yellow),
                        "orange" => Some(TextColor::Orange),
                        "pink" => Some(TextColor::Pink),
                        "purple" => Some(TextColor::Purple),
                        "brown" => Some(TextColor::Brown),
                        "gray" => Some(TextColor::Gray),
                        _ => None,
                    };
                }
            }
        }
        None
    }
    
    /// Check if the span has an underline class
    fn is_underline(&self, classes: &[String]) -> bool {
        classes.contains(&"underline".to_string())
    }
}

impl PandocElementHandler for SpanHandler {
    fn can_handle(&self, element: &Inline) -> bool {
        matches!(element, Inline::Span(_, _))
    }

    fn handle(&self, element: &Inline, builder: &mut TextBuilder) -> Result<(), ConversionError> {
        if let Inline::Span(attr, content) = element {
            let converter_ref = self.converter.borrow();
            if let Some(converter) = converter_ref.as_ref() {
                // Create a nested builder with any formatting from the span attributes
                let mut nested_builder = builder.apply_formatting(|annotations| {
                    // Check if this is an underline span
                    if self.is_underline(&attr.classes) {
                        annotations.underline = true;
                    }
                    
                    // Check for color styling
                    if let Some(color) = self.parse_color(&attr.classes) {
                        annotations.color = color;
                    }
                });
                
                // If the converter has no handlers, we need to use a clone with proper handlers
                let converter_to_use = if converter.handlers.is_empty() {
                    PandocTextConverter::with_config(converter.config.clone())
                } else {
                    converter.clone()
                };
                
                // Process the nested content
                converter_to_use.convert_content(content, &mut nested_builder)?;
                
                // Transfer the formatting back
                if let Ok(rich_texts) = nested_builder.build() {
                    builder.rich_texts.extend(rich_texts);
                }
                
                Ok(())
            } else {
                Err(ConversionError::InvalidFormat("Converter not initialized".to_string()))
            }
        } else {
            Err(ConversionError::UnsupportedElement(format!("{:?}", element)))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pandoc_types::definition::{Attr, Inline, MathType, Target};

    // Helper function to create basic Pandoc inline elements
    fn create_text_inline(text: &str) -> Vec<Inline> {
        vec![Inline::Str(text.to_string())]
    }

    #[test]
    fn test_convert_simple_text() {
        let converter = PandocTextConverter::new();
        let elements = create_text_inline("Hello world");
        
        let result = converter.convert(&elements).unwrap();
        
        assert_eq!(result.len(), 1);
        match &result[0] {
            RichText::Text { text, .. } => {
                assert_eq!(text.content, "Hello world");
                assert!(text.link.is_none());
            },
            _ => panic!("Expected Text variant"),
        }
    }

    #[test]
    fn test_convert_spaces() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Str("Hello".to_string()),
            Inline::Space,
            Inline::Str("world".to_string()),
        ];
        
        let result = converter.convert(&elements).unwrap();
        
        assert_eq!(result.len(), 1);
        match &result[0] {
            RichText::Text { text, .. } => {
                assert_eq!(text.content, "Hello world");
            },
            _ => panic!("Expected Text variant"),
        }
    }

    #[test]
    fn test_convert_multiple_spaces() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Str("Hello".to_string()),
            Inline::Space,
            Inline::Space,
            Inline::Str("world".to_string()),
        ];
        
        let result = converter.convert(&elements).unwrap();
        
        assert_eq!(result.len(), 1);
        match &result[0] {
            RichText::Text { text, .. } => {
                assert_eq!(text.content, "Hello  world");
            },
            _ => panic!("Expected Text variant"),
        }
    }

    #[test]
    fn test_convert_line_breaks() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Str("Hello".to_string()),
            Inline::LineBreak,
            Inline::Str("world".to_string()),
        ];
        
        let result = converter.convert(&elements).unwrap();
        
        assert_eq!(result.len(), 1);
        match &result[0] {
            RichText::Text { text, .. } => {
                assert_eq!(text.content, "Hello\nworld");
            },
            _ => panic!("Expected Text variant"),
        }
    }

    #[test]
    fn test_convert_bold_text() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Strong(vec![Inline::Str("Bold text".to_string())]),
        ];
        
        let result = converter.convert(&elements).unwrap();
        
        assert_eq!(result.len(), 1);
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Bold text");
                if let Some(ann) = annotations {
                    assert!(ann.bold);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }

    #[test]
    fn test_convert_italic_text() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Emph(vec![Inline::Str("Italic text".to_string())]),
        ];
        
        let result = converter.convert(&elements).unwrap();
        
        assert_eq!(result.len(), 1);
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Italic text");
                if let Some(ann) = annotations {
                    assert!(ann.italic);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_strikethrough_text() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Strikeout(vec![Inline::Str("Strikethrough text".to_string())]),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Strikethrough text");
                if let Some(ann) = annotations {
                    assert!(ann.strikethrough);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_code() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Code(Attr::default(), "code example".to_string()),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "code example");
                if let Some(ann) = annotations {
                    assert!(ann.code);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_math() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Math(MathType::InlineMath, "E=mc^2".to_string()),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Equation { equation, .. } => {
                assert_eq!(equation.expression, "E=mc^2");
            },
            _ => panic!("Expected Equation variant"),
        }
    }
    
    #[test]
    fn test_convert_link() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Link(
                Attr::default(),
                vec![Inline::Str("Link text".to_string())],
                Target {
                    url: "https://example.com".to_string(),
                    title: String::new(),
                },
            ),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, href, .. } => {
                assert_eq!(text.content, "Link text");
                assert!(text.link.is_some());
                if let Some(link) = &text.link {
                    assert_eq!(link.url, "https://example.com");
                }
                assert_eq!(href, &Some("https://example.com".to_string()));
            },
            _ => panic!("Expected Text variant with link"),
        }
    }
    
    #[test]
    fn test_convert_nested_formatting() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Strong(vec![
                Inline::Emph(vec![
                    Inline::Str("Bold and italic".to_string())
                ])
            ]),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Bold and italic");
                if let Some(ann) = annotations {
                    assert!(ann.bold);
                    assert!(ann.italic);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_color() {
        let converter = PandocTextConverter::new();
        
        // Create a span with a color class
        let mut attr = Attr::default();
        attr.classes.push("color-red".to_string());
        
        let elements = vec![
            Inline::Span(
                attr,
                vec![Inline::Str("Colored text".to_string())]
            ),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Colored text");
                if let Some(ann) = annotations {
                    assert_eq!(ann.color, TextColor::Red);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_background_color() {
        let converter = PandocTextConverter::new();
        
        // Create a span with a background color class
        let mut attr = Attr::default();
        attr.classes.push("color-blue-background".to_string());
        
        let elements = vec![
            Inline::Span(
                attr,
                vec![Inline::Str("Background colored text".to_string())]
            ),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Background colored text");
                if let Some(ann) = annotations {
                    assert_eq!(ann.color, TextColor::BlueBackground);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_underline() {
        let converter = PandocTextConverter::new();
        
        // Create a span with underline class
        let mut attr = Attr::default();
        attr.classes.push("underline".to_string());
        
        let elements = vec![
            Inline::Span(
                attr,
                vec![Inline::Str("Underlined text".to_string())]
            ),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, annotations, .. } => {
                assert_eq!(text.content, "Underlined text");
                if let Some(ann) = annotations {
                    assert!(ann.underline);
                } else {
                    panic!("Expected annotations");
                }
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_complex_formatting() {
        let converter = PandocTextConverter::new();
        
        // Create a complex element with multiple formatting types
        let mut color_attr = Attr::default();
        color_attr.classes.push("color-red".to_string());
        
        let elements = vec![
            Inline::Span(
                color_attr,
                vec![
                    Inline::Strong(vec![
                        Inline::Emph(vec![
                            Inline::Str("Complex ".to_string()),
                        ]),
                        Inline::Str("formatting".to_string()),
                    ]),
                ]
            ),
        ];
        
        let result = converter.convert(&elements).unwrap();
        
        // Verify all formatting is correctly applied
        // Note: In this case, we might get multiple rich text objects due to
        // the way the formatting is applied across different text segments
        assert!(result.len() >= 1);
        
        // Ensure all content is present
        let all_text = result.iter().map(|rt| match rt {
            RichText::Text { text, .. } => text.content.clone(),
            RichText::Equation { equation, .. } => equation.expression.clone(),
            _ => String::new(),
        }).collect::<Vec<String>>().join("");
        
        assert!(all_text.contains("Complex "));
        assert!(all_text.contains("formatting"));
    }
    
    #[test]
    fn test_convert_unicode_characters() {
        let converter = PandocTextConverter::new();
        let elements = vec![
            Inline::Str("Unicode: 你好, こんにちは, 안녕하세요, Привет, 😊".to_string()),
        ];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 1);
        
        match &result[0] {
            RichText::Text { text, .. } => {
                assert_eq!(text.content, "Unicode: 你好, こんにちは, 안녕하세요, Привет, 😊");
            },
            _ => panic!("Expected Text variant"),
        }
    }
    
    #[test]
    fn test_convert_empty_content() {
        let converter = PandocTextConverter::new();
        let elements: Vec<Inline> = vec![];
        
        let result = converter.convert(&elements).unwrap();
        assert_eq!(result.len(), 0);
    }
}