mod fixtures {
    pub mod notion_test_helpers;
    pub mod pretty_diff;
    pub mod roundtrip_utils;
}

use notion_client::objects::block::Block as NotionBlock;
use pandoc_notion::n2p::NotionToPandocVisitor;
use pandoc_notion::prelude::*;
use pandoc_types::definition::{Block as PandocBlock, Pandoc as PandocDocument};
use std::error::Error;
use std::fs;
use std::path::Path;

#[test]
fn test_bullet_list_issue() -> Result<(), Box<dyn Error>> {
    // Load the Notion blocks from the file generated by the original test
    let blocks_file = "bulleted_list_notion_blocks.json";
    if !Path::new(blocks_file).exists() {
        println!("Notion blocks file not found. Run the notion_syntax_tests first.");
        println!("cargo test --test notion_syntax_tests test_bulleted_list -- --nocapture");
        return Ok(());
    }

    // Load the Notion blocks
    let blocks_json = fs::read_to_string(blocks_file)?;
    let notion_blocks: Vec<NotionBlock> = serde_json::from_str(&blocks_json)?;

    println!("===== LOADED NOTION BLOCKS =====");
    println!("Number of blocks: {}", notion_blocks.len());
    debug_blocks(&notion_blocks);

    // Create a text processor for converting the AST to markdown
    let text_processor = create_text_processor();

    // Convert using standard visitor
    println!("\n===== STANDARD CONVERSION =====");
    let standard_blocks = convert_with_standard_visitor(&notion_blocks);
    let standard_ast = create_document(standard_blocks.clone());

    // Save the standard AST for inspection
    let standard_ast_json = serde_json::to_string_pretty(&standard_ast)?;
    fs::write("debug_standard_ast.json", standard_ast_json)?;

    // Convert to markdown
    let standard_markdown = text_processor.ast_to_text(&standard_ast, TextFormat::Markdown)?;
    fs::write("debug_standard_output.md", &standard_markdown)?;
    println!("{}", standard_markdown);

    // Convert using fixed approach
    println!("\n===== FIXED CONVERSION =====");
    let fixed_blocks = convert_with_fixed_approach(&notion_blocks);
    let fixed_ast = create_document(fixed_blocks.clone());

    // Save the fixed AST for inspection
    let fixed_ast_json = serde_json::to_string_pretty(&fixed_ast)?;
    fs::write("debug_fixed_ast.json", fixed_ast_json)?;

    // Convert to markdown
    let fixed_markdown = text_processor.ast_to_text(&fixed_ast, TextFormat::Markdown)?;
    fs::write("debug_fixed_output.md", &fixed_markdown)?;
    println!("{}", fixed_markdown);

    // Compare the results
    println!("\n===== DIFF BETWEEN STANDARD AND FIXED =====");
    let diff = similar::TextDiff::from_lines(&standard_markdown, &fixed_markdown);
    for change in diff.iter_all_changes() {
        let prefix = match change.tag() {
            similar::ChangeTag::Delete => "- ",
            similar::ChangeTag::Insert => "+ ",
            similar::ChangeTag::Equal => "  ",
        };
        print!("{}{}", prefix, change);
    }

    Ok(())
}

// Create a Pandoc document from blocks
fn create_document(blocks: Vec<PandocBlock>) -> PandocDocument {
    PandocDocument {
        meta: Default::default(),
        blocks,
    }
}

// Standard conversion using the existing visitor
fn convert_with_standard_visitor(blocks: &[NotionBlock]) -> Vec<PandocBlock> {
    let config = ConversionConfig::default();
    let visitor = NotionToPandocVisitor::with_config(config);
    visitor.convert_blocks(blocks)
}

// Fixed conversion approach that merges consecutive bullet lists
fn convert_with_fixed_approach(blocks: &[NotionBlock]) -> Vec<PandocBlock> {
    // First convert using standard visitor
    let config = ConversionConfig::default();
    let visitor = NotionToPandocVisitor::with_config(config);
    let raw_blocks = visitor.convert_blocks(blocks);

    // Now merge consecutive bullet lists
    merge_consecutive_bullet_lists(raw_blocks)
}

// Function to merge consecutive bullet lists
fn merge_consecutive_bullet_lists(blocks: Vec<PandocBlock>) -> Vec<PandocBlock> {
    let mut result = Vec::new();
    let mut current_list: Option<Vec<Vec<PandocBlock>>> = None;

    for block in blocks {
        match block {
            PandocBlock::BulletList(items) => {
                match &mut current_list {
                    // If we already have a bullet list being built, append to it
                    Some(list_items) => {
                        list_items.extend(items);
                    }
                    // Start a new bullet list
                    None => {
                        current_list = Some(items);
                    }
                }
            }
            other_block => {
                // If we have a bullet list being built, finalize it
                if let Some(list_items) = current_list.take() {
                    result.push(PandocBlock::BulletList(list_items));
                }
                // Add the non-bullet-list block
                result.push(other_block);
            }
        }
    }

    // Don't forget to add the last bullet list if there is one
    if let Some(list_items) = current_list.take() {
        result.push(PandocBlock::BulletList(list_items));
    }

    result
}

// Create a simple bullet list item
#[allow(dead_code)]
fn create_bullet_list_item(text: &str) -> Vec<PandocBlock> {
    use pandoc_types::definition::{Attr, Inline};

    // Create the inline content (text)
    let plain_text = vec![Inline::Str(text.to_string())];

    // Create a span with default attributes
    let span = Inline::Span(Attr::default(), plain_text);

    // Create a Plain block with the span
    let plain = PandocBlock::Plain(vec![span]);

    // Create the bullet list with a single item
    vec![PandocBlock::BulletList(vec![vec![plain]])]
}

// Debug function to print block details
fn debug_blocks(blocks: &[NotionBlock]) {
    for (i, block) in blocks.iter().enumerate() {
        println!("Block #{}: Type: {:?}", i, block.block_type);
        // Add more detailed debug info if needed
    }
}

#[test]
fn test_consecutive_bullet_lists_issue() -> Result<(), Box<dyn Error>> {
    println!("\n===== TESTING CONSECUTIVE BULLET LISTS ISSUE =====");

    // Create a text processor for converting AST to markdown
    let text_processor = create_text_processor();

    // Create multiple separate bullet list blocks to trigger the issue
    let mut blocks = Vec::new();

    // Add first bullet list (first item)
    blocks.push(PandocBlock::BulletList(vec![vec![PandocBlock::Plain(
        vec![pandoc_types::definition::Inline::Str(
            "First item".to_string(),
        )],
    )]]));

    // Add second bullet list (second item) - this is the key part that will trigger the issue
    blocks.push(PandocBlock::BulletList(vec![vec![PandocBlock::Plain(
        vec![pandoc_types::definition::Inline::Str(
            "Second item".to_string(),
        )],
    )]]));

    // Add third bullet list (third item)
    blocks.push(PandocBlock::BulletList(vec![vec![PandocBlock::Plain(
        vec![pandoc_types::definition::Inline::Str(
            "Third item".to_string(),
        )],
    )]]));

    // Create a document with the separate bullet lists
    let doc = PandocDocument {
        meta: Default::default(),
        blocks,
    };

    // Convert to markdown - this should trigger the issue with + <!-- -->
    let markdown = text_processor.ast_to_text(&doc, TextFormat::Markdown)?;
    println!(
        "Standard conversion with separate bullet lists:\n{}",
        markdown
    );
    fs::write("debug_separate_lists.md", &markdown)?;

    // Check if the output contains the problematic <!-- --> marker
    if markdown.contains("<!-- -->") {
        println!("FOUND ISSUE: The output contains HTML comments");
    } else {
        println!("No HTML comments found in the output");
    }

    // Now fix it by merging the bullet lists
    let fixed_blocks = merge_consecutive_bullet_lists(doc.blocks);
    let fixed_doc = PandocDocument {
        meta: Default::default(),
        blocks: fixed_blocks,
    };

    // Convert to markdown again
    let fixed_markdown = text_processor.ast_to_text(&fixed_doc, TextFormat::Markdown)?;
    println!(
        "Fixed conversion with merged bullet lists:\n{}",
        fixed_markdown
    );
    fs::write("debug_merged_lists.md", &fixed_markdown)?;

    // Compare the results
    println!("\n===== DIFF BETWEEN SEPARATE AND MERGED LISTS =====");
    let diff = similar::TextDiff::from_lines(&markdown, &fixed_markdown);
    for change in diff.iter_all_changes() {
        let prefix = match change.tag() {
            similar::ChangeTag::Delete => "- ",
            similar::ChangeTag::Insert => "+ ",
            similar::ChangeTag::Equal => "  ",
        };
        print!("{}{}", prefix, change);
    }

    Ok(())
}
